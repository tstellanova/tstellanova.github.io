
# Lifetime of a Driver Part 1: PX4 running on NuttX

The PX4 autopilot running on the NuttX RTOS is an interesting case study.
NuttX itself provides a variety of POSIX-compliant facilities for supporting driver-like activities,
such as streams, file descriptors, paths, and so forth.  However, that is not enough to
support high-speed handling of sensors and actuators on an embedded platform. 

Because of the nature of the technical domain (robotic guidance, navigation, and control),
PX4 must pull data from a wide variety of sensors and send commands to a wide variety of actuators.
The sensors vary widely in their bandwidth and latency requirements, everything from 
gyroscopes to barometers, GPS to LIDAR. 

PX4 has converged on a set of interfaces for most actively used drivers. This consists of 
two main components: the core driver, and a command line wrapper. 

Keep in mind that NuttX does provide a kind of shell: `nsh`, 
[the NuttX Shell](https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=139629410).
At startup tasks can be started from nsh.

## Command Line Wrapper

Most PX4 drivers have a command line wrapper that may be called from nsh, the NuttX shell.
These wrappers generally provide commands such as:
- start:  Start the core driver running 
- stop: Stop the driver running
- status: Print the status of the driver

It's important to note that the wrapper itself is not creating a NuttX process:
its start method simply instantiates a core driver and stores it.
Any subequent commands issued to the wrapper simply poke at the existing driver instance. 

### Example

Take for example the `ms5611` barometer wrapper: `ms5611_main` is the `main()` function for this wrapper.
This might be invoked under nsh using the command line
`ms5611 start` with various bus-selecting options (SPI, I2C).
This start method in turn creates the core driver.

## Core Drivers: ScheduledWorkItem

Take for instance the MS5611 class:
`class MS5611 : public px4::ScheduledWorkItem {..}`
This is the class that performs the core activities we normally
associate with a driver: configuring an attached device,
reading data from it, communicating with it. 

Most core drivers are a kind of PX4 `ScheduledWorkItem`.  
WorkItems can be added to one of PX4's WorkQueues.
This is how they are able to schedule asynchronous processing. 

The core driver provides essentially a `Run` method that can reschedule 
itself for running at some future time. 
The run method typically does some tiny amount of work 
(for example, starting the process of taking a sensor measurement in `measure` or
subsequently collecting the results of that measurement in `collect`)
then calls `ScheduleDelayed` to schedule itself to run again in the future.

- init. Called synchronously by the wrapper
- start. Schedules the driver to begin asap (using `ScheduleNow`)
- stop. Stops the driver from running (using `ScheduleClear` to deschedule it)
- Run. Performs work asychronously, called by the WorkQueue. 

- 
- trampoline
- asynchronous processing (async from the nuttx process)
- command line tools


